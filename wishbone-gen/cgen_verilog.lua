#!/usr/bin/lua

-- wbgen2, (c) 2010 Tomasz Wlostowski/CERN BE-Co-HT
-- LICENSED UNDER GPL v2

-- File: cgen_vhdl.lua
-- The Verilog code generator


-- verilog signal types
VLOG_WIRE = 1;
VLOG_REG = 2;

-- does the obvious thing...
function cgen_verilog_header()
    emit("//////////////////////////////////////////////////////////////////////////////////////");
    emit("// Title          : Wishbone slave core for "..periph.name);
    emit("//////////////////////////////////////////////////////////////////////////////////////");
    emit("// File           : "..options.output_hdl_file);
    emit("// Author         : auto-generated by wbgen2 from "..input_wb_file);
    emit("// Created        : "..os.date());
    emit("// Standard       : Verilog 2001");
    emit("//////////////////////////////////////////////////////////////////////////////////////");
    emit("// THIS FILE WAS GENERATED BY wbgen2 FROM SOURCE FILE "..input_wb_file);
    emit("// DO NOT HAND-EDIT UNLESS IT'S ABSOLUTELY NECESSARY!");
    emit("//////////////////////////////////////////////////////////////////////////////////////");
		emit("");
end

-- generates verilog module header with port list.
function cgen_verilog_module()
	local last;

	indent_zero();
	emit ("module "..periph.hdl_entity.." (");
	indent_right();

  for i=1,table.getn(g_portlist) do
		local port = g_portlist[i];
		  
		if(i == table.getn(g_portlist)) then
			last = true;
		else
		  last = false;
		end

		if(port.comment ~= nil) then
			emitx("// "..port.comment.."\n");
		end
	
	
		local dirstr;
		
		if(port.dir=="in") then
		 dirstr="input";
		elseif(port.dir=="out") then
		 dirstr="output";
		elseif(port.dir=="inout") then
		 dirst="inout";
		end

		if(port.vlog_type == VLOG_REG) then
		 dirstr=dirstr.." reg";
		end

		local rangestr="";

		if(port.range > 0) then
		  rangestr = "["..(port.range-1)..":0]";
		end    

		local line = string.format("%-11s %-6s %s", dirstr, rangestr, port.name);
		line=line..csel(last, "", ",");
		emit(line);
  end
    
	indent_left();
 	emit(");");
	indent_left();
	emit("");

	for i,v in pairs (g_siglist) do

		local rwire=csel(v.vlog_type==VLOG_REG, "reg", "wire");
		local rangestr="";

		if(v.range > 0) then
			rangestr=string.format("[%d:0] ", v.range-1);
		end

		emit(string.format("%-5s %-7s %s;", rwire, rangestr, v.name));
	end
	emit("");

	indent_right();
	
end

function cgen_verilog_ending()
	indent_left();
	emit("endmodule");
end




-- Generates the vlog code from syntax tree <tree>, writing it into previously chosen file.
function cgen_generate_verilog_code(tree)

	local inside_process = false;

	function find_code(node, t)
		for i,v in ipairs(node) do if ((v.t ~= nil) and (v.t == t)) then return v; end end
		return nil;
	end

	function cgen_verilog_syncprocess(node)
		local vrst = find_code(node.code, "reset");

		if(vrst ~= nil and options.reset_type=="asynchronous") then
	 		emit("always @(posedge "..node.clk.." or "..csel(vrst.level==0, "negedge", "posedge").." rst_n_i) begin")
	 	else
	 		emit("always @(posedge "..node.clk..") begin");
	 	end

		indent_right();

		inside_process = true;

		local vpe = find_code(node.code, "posedge");
			
		if(vpe == nil) then die("verilog code generation error: no vposedge defined for vsyncprocess"); end

		if(vrst ~= nil) then
			emit("if ("..node.rst.." == 1'b"..vrst.level..") begin ");
			indent_right();
			recurse(vrst.code);
			indent_left();
			emit("end else begin");
			indent_right();
		end

		recurse(vpe.code);		

		if(vrst ~= nil) then
			indent_left();
			emit("end");
	 	end

		indent_left();
		emit("end");	
		emit("");

		inside_process = false;

	end

	function node_typesize(node)
		local ts = {};
		local sig;

		ts.node = node;

		if(type(node) == "table") then
			if(node.t ~= nil) then
			 if(node.t == "index") then
					sig = cgen_find_sigport(node.name);
				--	print("VI ", node.name, node.h, node.l);
					ts.h=node.h;
					ts.l=node.l;
					ts.sig=sig;
					ts.name=sig.name;
					ts.type=sig.type;


					if(ts.l ~= nil) then
						 ts.size = ts.h-ts.l+1;
					else
						 ts.size = 1;
				 end
			
					return ts;			
				elseif (node.t == "others") then
					ts.type = OTHERS;
					ts.size = 0;
					ts.value = node.val;
					return ts;
			 	elseif(node.t == "undefined") then
			 		
					ts.type = UNDEFINED;
					return ts;
				else
					ts.type = EXPRESSION;
					ts.code = node;
					return ts;
				end
			 end
		 elseif(type(node) == "string") then
			sig = cgen_find_sigport(node);
			ts.sig=sig;
			ts.size = sig.range;
			ts.type = sig.type;
			ts.name = node;
			return ts;
		 elseif(type(node) == "number") then
			ts.type = INTEGER;
			ts.name = node;
			ts.size = 0;
			return ts;
		else 
			die("node_typesize(): unknown node?");
		end
	end

	function gen_subrange(t)
		if(type(t.node) == "table" and t.node.t == "openpin") then
			return "";
		end

		if(t.h ~= nil and t.l == nil) then
			return t.name.."["..t.h.."]";
		elseif(t.h ~= nil and t.l ~= nil) then
			return t.name.."["..t.h..":"..t.l.."]";
		else
			return t.name;
		end
	end

	function calc_size(t)
		if(t.h ~= nil and t.l == nil) then
			return 1;
		elseif(t.h ~= nil and t.l ~= nil) then
			return t.h-t.l+1; 
		else
			local sig= cgen_find_sigport(t.name);
			return sig.range;
		end
	end


	function cgen_verilog_assign(node)
		local tsd = node_typesize(node.dst);
		local tss = node_typesize(node.src);

		tsd.sig.vlog_type = csel(inside_process, VLOG_REG, VLOG_WIRE);
	
		emiti();
		if (tss.type == OTHERS or tss.type == UNDEFINED) then -- vhdl dst <= (others => x) expression
			local bin = string.format("%d'b", tsd.size);
			local val = csel(tss.type == UNDEFINED, "X", csel(tss.value == 1, "1", "0"));

			for i=1,tsd.size do
				bin=bin..val;
			end

			emitx(csel(not inside_process, "assign ", "")..gen_subrange(tsd)..csel(inside_process," <= ", " = "));
			emitx(bin..";\n");

		elseif (tss.type == EXPRESSION) then
			emitx(csel(not inside_process, "assign ", "")..gen_subrange(tsd)..csel(inside_process," <= ", " = "));
			recurse({tss.code});
			emitx(";\n");
		else
			emitx(csel(not inside_process, "assign ", "")..gen_subrange(tsd)..csel(inside_process," <= ", " = ")..gen_subrange(tss)..";\n");
		end
	end

	function cgen_verilog_if(node)
		emiti(); emitx("if (");

		recurse(node.cond);
		emitx(") begin\n");
		if(node.code_else ~= nil) then
		indent_right();
		recurse(node.code);
		indent_left();
		emit("end else begin");
		indent_right();
		recurse(node.code_else);
		indent_left();
		emit("end");
		else
		indent_right();
		recurse(node.code);
		indent_left();
		emit("end");

		end
	
	end

	function cgen_verilog_not(node)
		local tsa = node_typesize(node.a);

		emitx("! ");

		if(tsa.type == EXPRESSION) then
			emitx("("); recurse({node.a}); emitx(")");
		else
			emitx(gen_subrange(tsa));
		end
	end


	function cgen_verilog_binary_op(node)
		local tsa = node_typesize(node.a);
		local tsb = node_typesize(node.b);
		local op = node.t;

		if(tsa.type == EXPRESSION) then
			emitx("("); recurse({node.a}); emitx(")");
		else
			emitx(gen_subrange(tsa));
		end


		if(op=="eq") then emitx(" == "); end
		if(op=="and") then emitx(" && "); end
		if(op=="or") then emitx(" || "); end
		if(op=="sub") then emitx(" - "); end
		if(op=="add") then emitx(" + "); end

		if(tsb.type == EXPRESSION) then
			emitx("("); recurse({node.b}); emitx(")");
		else
			emitx(gen_subrange(tsb));
		end
	end


	function cgen_verilog_comment(node)
		emitx("// "..node.str.."\n");
	end


	-- switch/case statement --
	function cgen_verilog_switch(node)

		local tsa = node_typesize(node.a);

		emiti(); emitx("case ");

		if(tsa.type == EXPRESSION) then
			emitx("("); recurse({node.a}); emitx(")");
		else
			emitx("("..gen_subrange(tsa)..")");
		end	

		emit("");

		for i,v in pairs(node.code)  do

			if(v.t == "case") then			
				emit(string.format("%d'h%x: begin", tsa.size, v.a));
				indent_right();
				recurse({v.code});
				indent_left();
				emit("end");
			elseif(v.t == "casedefault") then			
				emit("default: begin");
				indent_right();
				recurse({v.code});
				indent_left();
				emit("end");
			end	


		end

		emit("endcase");

	end


	-- function instantiates and wires a VHDL component.
	function cgen_verilog_instance(node)
		local num_pmaps=0;
		local num_gmaps=0;
		local n;


	-- emit the instatiation code
		emitx(node.component.." ");

	-- count the number of PORT MAPs and GENERIC MAPs
		for i,v in pairs(node.maps) do
			if(v.t=="genmap") then
				num_gmaps=num_gmaps+1;
			elseif(v.t == "portmap") then
				num_pmaps=num_pmaps+1;
			end 
		end
	
	-- do we gave GENERIC MAPs?	
		if(num_gmaps > 0) then
			indent_right();
			emit("# (");
			indent_right();
			n=1;

	-- then emit all of them
			for i,v in pairs(node.maps) do
				if(v.t=="genmap") then
					local from = v.from;
					if(from == "true") then from = 1;
					elseif(from == "false") then from = 0; end				
					emit(string.format(".%-20s(%s)", v.to, from)..csel(n==num_gmaps,"",","));
					n=n+1;
				end
			end	
			indent_left();
			emit(")");
			indent_left();		
		end	

	-- do we have PORT MAPs?
		if(num_pmaps > 0) then
			indent_right();
			emit(node.name.." ( ");
			indent_right();
			n=1;
			for i,v in pairs(node.maps) do
				if(v.t=="portmap") then
				local tsd = node_typesize(v.from);
				emit(string.format(".%-20s(%s)", v.to, gen_subrange(tsd))..csel(n==num_pmaps,"",","));
				n=n+1;
				end
			end	
			indent_left();
			emit(");");
			indent_left();		
		end	

		emit("");
	end

	-- generates VHDL "pin => open" mapping
	function cgen_verilog_openpin(node)
-- just leave it empty :)
		emitx("");
	end
	
	function cgen_verilog_combprocess(node)
		local first_one = true;
		emiti();
		emitx("always @(");
		inside_process = true;
		for i,v in pairs(node.slist) do
			if(first_one) then
				first_one = false;
			else
				emitx(" or ");
			end
			emitx(v);
		end
		
		emit(")");
		emit("begin");

		indent_right();
		recurse(node.code);
		indent_left();
		inside_process = false;
		emit("end");	
		emit("");
		emit("");

	end




	function recurse(node)
		local generators = {
			["comment"] 			= cgen_verilog_comment;
			["syncprocess"] 	= cgen_verilog_syncprocess;
			["combprocess"] 	= cgen_verilog_combprocess;
			["assign"]			 	= cgen_verilog_assign;
			["if"]			 			= cgen_verilog_if;
			["eq"]					 	= cgen_verilog_binary_op;
			["add"]					 	= cgen_verilog_binary_op;		
			["sub"]					 	= cgen_verilog_binary_op;
			["or"]					 	= cgen_verilog_binary_op;
			["and"]					 	= cgen_verilog_binary_op;
			["not"]						= cgen_verilog_not;
			["switch"] 				= cgen_verilog_switch;
			["instance"]			= cgen_verilog_instance;
 			["openpin"]				= cgen_verilog_openpin;
		};


		for i,v in pairs(node) do
			-- no type? probably just a block of code. recurse it deeper.

			if(v.t == nil) then
				recurse(v);
			else
				local func = generators[v.t];
				if(func == nil) then
					die("Unimplemented generator: "..v.t);
				end
				func(v);
			end
		end
	end

	-- generate the header of the file
	cgen_new_snippet();
	cgen_verilog_header();
	local c_header = cgen_get_snippet();

	-- now recurse the syntax tree and generate the main code block. Also, classify all the signals as REGs or WIREs
	cgen_new_snippet();
	recurse(tree);
	cgen_verilog_ending();
	local c_body = cgen_get_snippet();

	-- generate the module definions and signals - this must done after the module body has been generated in order to determine whether to declare things
	-- as regs or wires.
	cgen_new_snippet();
	cgen_verilog_module();
	local c_mod = cgen_get_snippet();

	cgen_write_snippet(c_header);
	cgen_write_snippet(c_mod);
	cgen_write_snippet(c_body);

end
